---
title: kFrame总结
date: 2022-01-14 15:55:03 
permalink: /k-frame-learning/ 
id: k-frame-learning
categories:
  - 前端
tags:
  - 前端
  - Vue
  - 框架
---



# kFrame 总结

在k公司做了挺久，我想总结一下k公司的前端框架

## KeepAlive

```vue
    <transition name="fade-transform" mode="out-in">
        <keep-alive :include="keepAliveIncludeList" v-if="customize.keepAliveMode">
            <router-view :key="key"></router-view>
        </keep-alive>
        <keep-alive :exclude="keepAliveExcludeList" :max="customize.keepAliveMax" v-else>
            <router-view :key="key"></router-view>
        </keep-alive>
    </transition>
```

将`keepAliveIncludeList`、`keepAliveExcludeList`放在vuex中，并且根据配置来切换keepAlive的模式，每次切换模式都会清空缓存（因为 v-if 和 v-else 的变换）。

## 如何保证配置都被读取后进行页面加载

```js
Global.init().then(async () => {
  new Vue({
    el: '#app',
    router: router,
    store: store,
    render: h => h(App)
  });
}).catch((err) => {
  console.error('global init err' + err);
});
```

通过全局的init方法读取配置，然后再 new Vue 实例。

## 全局工具的提供

```js
import Global from 'utils/global';
```

框架中会这样使用 Global、Utils等工具类函数。

同时框架提供了默认的utils。

为了使用框架的utils需要在项目中，创建utils/global.js：

```js
/** global.js **/
import global from 'kframe/utils/global';

// 自定义 或者 覆盖 global 上的方法
// global.xxx = () => {}

export default global;
```

## 换肤

每种样式需要写一套，分别放在light、dark目录下面。

编译的时候，使用gulp将样式分别编译到 static/light 、 static/dark 目录下面。

初始化的时候，加入`<style>`标签；

换肤：改变`<style>`路径中的dark、light关键词

gulp 编译使用的插件 `gulp-px2rem-plugin` `gulp-sass` `gulp-autoprefixer`   `gulp-cssmin` `node-sass-tilde-importer`



## webpack 配置

package.json

```json
{
    	"scripts": {
		"import": "node submodule import -ALL",
		"dev": "node --max_old_space_size=4096 node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --progress --config build/webpack.dev.conf.js",
		"start": "npm run dev",
		"lint-fix": "eslint --fix --ext .js,.vue src",
		"unit": "jest --config test/unit/jest.conf.js --coverage",
		"e2e": "node test/e2e/runner.js",
		"test": "npm run unit && npm run e2e",
		"lint": "eslint --ext .js,.vue src test/unit/specs test/e2e/specs",
		"clean": "rimraf dist && rimraf  static/theme/dark/lib && rimraf  static/theme/light/lib",
		"build:theme:dark": "gulp build --gulpfile static/theme/dark/gulpfile.js",
		"build:theme:light": "gulp build --gulpfile static/theme/light/gulpfile.js",
		"build:theme": "npm run clean && npm run build:theme:dark && npm run build:theme:light",
		"build": "npm run build:theme && node --max_old_space_size=4096 build/build.js",
		"server": "node test/webserver/index.js"
	}
}
```

可以看到，在build的时候，会先使用gulp编译主题，这样做也是考虑到了换肤方案。然后就是执行build.js。

由于项目比较大，所以内存给了4G。

dev使用了webpack-dev-server 然后提供dev的webpack配置。

dev配置是基于base配置，所以先看base配置

```js
'use strict';
const path = require('path');
const utils = require('./utils');
const config = require('../config');
const vueLoaderConfig = require('./vue-loader.conf');
const {readdirSync, existsSync,mkdirSync,lstatSync} = require('fs');
let excludeEslint = [];

// 将submodule的静态资源放入excludeEslint
readdirSync('./submodule').forEach(item => {
	excludeEslint.push(resolve(`submodule/${item}/assets`));
});
// 提供resolve，因为这个文件在/build/目录下面
function resolve (dir) {
	return path.join(__dirname, '..', dir);
}
// 将内部组件的静态资源都放入项目的静态资源
if(existsSync(`./node_modules/@k-components`)){
	let dirs = readdirSync('./node_modules/@k-components');
	dirs.forEach(name =>{
		if(existsSync(`./node_modules/@k-components/${name}/static/${name}`) && lstatSync(`./node_modules/@k-components/${name}/static/${name}`).isDirectory()){
			if(!existsSync(`./static/${name}`)){
				mkdirSync(`./static/${name}`);
			}
			utils.existsDst(`./node_modules/@k-components/${name}/static/${name}`,`./static/${name}`, utils.copy);
		}
	});
}
module.exports = {
	node:{fs:'empty'},
	context: path.resolve(__dirname, '../'),
	entry: {
		main: ['babel-polyfill', './main/main.js']
	},
	output: {
		path: config.build.assetsRoot,
		filename: '[name].js',
		publicPath: process.env.NODE_ENV === 'production'
			? config.build.assetsPublicPath
			: config.dev.assetsPublicPath
	},
	resolve: {
		extensions: ['.js', '.vue', '.json'],
		alias: {
			'vue$': 'vue/dist/vue.esm.js',
			'main': resolve('main'),
			'submodule': resolve('submodule'),
			'utils': resolve('utils'),
			'config': resolve('config'),
			'static': path.resolve(__dirname, '../static') // 不参与打包文件路径
		}
	},
	module: {
		unknownContextCritical : false,
		rules: [
            // eslint
			...(config.dev.useEslint ? [{
				test: /\.(js|vue)$/,
				loader: 'eslint-loader',
				enforce: 'pre',
				include: [resolve('submodule'), resolve('main'), resolve('test')],
				exclude: excludeEslint,
				options: {
					formatter: require('eslint-friendly-formatter'),
					emitWarning: !config.dev.showEslintErrorsInOverlay
				}
			}] : []),
            // vue
			{
				test: /\.vue$/,
				loader: 'vue-loader',
				options: vueLoaderConfig
			},
            // babel 需要一同将内部的组件包括
			{
				test: /\.js$/,
				loader: 'babel-loader',
				include: [resolve('submodule'), resolve('main'), resolve('node_modules/@k-components/k-baseui'), resolve('config'), resolve('build'), resolve('static'), resolve('utils'), resolve('test')]
			},
            // 样式
			{
				test: /\.sass$/,
				loaders: ['style', 'css', 'scss']
			},
            // 其他资源
			{
				test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
				loader: 'url-loader',
				options: {
					limit: 10000,
					name: utils.assetsPath('img/[name].[hash:7].[ext]')
				}
			},
			{
				test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
				loader: 'url-loader',
				options: {
					limit: 10000,
					name: utils.assetsPath('media/[name].[hash:7].[ext]')
				}
			},
			{
				test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
				loader: 'url-loader',
				options: {
					limit: 10000,
					name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
				}
			}
		]
	}
};
```

接下来是dev.config

```js
'use strict'
const utils = require('./utils')
const webpack = require('webpack')
const config = require('../config')
const merge = require('webpack-merge')
const baseWebpackConfig = require('./webpack.base.conf')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')
const portfinder = require('portfinder');
const {readdirSync, lstatSync, existsSync} = require('fs');
const htmlWebpackPluginConfig = {
	filename: 'index.html',
	template: `index.html`,
	inject: true,
	chunks: ['main']
}

// 内部插件
readdirSync('./submodule').forEach(name => {
	if(lstatSync(`./submodule/${name}`).isDirectory() && existsSync(`./submodule/${name}/package.json`)){
		let packageJson = require(`../submodule/${name}/package.json`);
		console.log('packageJson>>>', packageJson);
		if(packageJson.scripts['sockjs']){
			htmlWebpackPluginConfig.sockjs = true;
		}
	}
});

// 首先合并基础配置
const devWebpackConfig = merge(baseWebpackConfig, {
	module: {
		rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
	},
	// cheap-module-eval-source-map is faster for development
	devtool: config.dev.devtool,

	// these devServer options should be customized in /config/index.js
	devServer: {
		clientLogLevel: 'warning',
		historyApiFallback: true,
		hot: true,
		compress: true,
		host: process.env.HOST || config.dev.host,
		port: process.env.PORT || config.dev.port,
		open: config.dev.autoOpenBrowser,
		overlay: config.dev.errorOverlay ? {
			warnings: false,
			errors: true,
		} : false,
		publicPath: config.dev.assetsPublicPath,
		proxy: config.dev.proxyTable,
		quiet: true, // necessary for FriendlyErrorsPlugin
		watchOptions: {
			poll: config.dev.poll,
		}
	},
	plugins: [
		new webpack.DefinePlugin({
			'process.env': require('../config/dev.env')
		}),
		new webpack.HotModuleReplacementPlugin(),
		new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.
		new webpack.NoEmitOnErrorsPlugin(),
		// https://github.com/ampedandwired/html-webpack-plugin
		new HtmlWebpackPlugin(htmlWebpackPluginConfig)
	]
})

module.exports = new Promise((resolve, reject) => {
	portfinder.basePort = process.env.PORT || config.dev.port
	portfinder.getPort((err, port) => {
		if (err) {
			reject(err)
		} else {
		// publish the new Port, necessary for e2e tests
		process.env.PORT = port
		// add port to devServer config
		devWebpackConfig.devServer.port = port

		// Add FriendlyErrorsPlugin
		devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({
			compilationSuccessInfo: {
				messages: [`Your application is running here: http://${config.dev.host}:${port}`],
			},
			onErrors: config.dev.notifyOnErrors
				? utils.createNotifierCallback()
				: undefined
		}))

		resolve(devWebpackConfig)
		}
	})
})
```

# k-frame lastest

项目中使用的并不是k-frame（vue 2 版本）中的最新版，于是，继续学习最新版

## index.js

首先是从window上获取Vue对象

```js
if (typeof window !== 'undefined' && window.Vue) {
    install(window.Vue);
}
```

然后执行install方法

```js
const install = function (Vue, opts = {}) {
    // 将框架的版本号写到window对象上
    if(!window['kframe']){
        window['kframe'] = {
            version: packageJson.version
        };
    }
    if (opts.$store && !opts.$store.hasModule('kframe')) {
        // 动态注册组件store数据
        opts.$store.registerModule('kframe', kframe);
    }

    // 注册框架需要的组件
    components.forEach(component => {
        Vue.component(component.name, component);
    });
    // 配置选项的处理
    if(opts.env){
        Comm.setEnv(opts.env);
    }
    if(opts.layout){
        Comm.setLayout(opts.layout);
    }
    if(opts.contentPath){
        Comm.setContentPath(opts.contentPath);
    }
    // 在Global记录Vue对象
    Global.setVue(Vue);
    // 在Vue对象上绑定框架提供的方法
    // I18n
    Vue.prototype.$t = t;
    // Global 框架的全局信息、方法
    Vue.prototype.$global = Global;
    // Util 工具方法
    Vue.prototype.$util = Util;
    // 框架权限
    Vue.prototype.$auth = Auth;
    // 框架的常量
    Vue.prototype.$constants = Constants;
    // axios实例（每个请求都会使用统一的方法，以便注入token，统一处理错误）
    Vue.prototype.$axios = Ajax;
    // event bus (没用过)
    Vue.prototype.$onMessage = onMessage;
    Vue.prototype.$removeOnMessage = removeOnMessage;
    Vue.prototype.$postMessage = postMessage;
    // 日志
    Vue.prototype.$logger = Logger; // 日志记录
    // 捕获全局错误信息 并且记录在日志里
    Vue.config.errorHandler = function (err, vm, info) {
      // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
      console.error('errorHandler --- ', err);

      let logData = {
        type: 'error',
        error: {
          message: err.toString(),
          fileName: err.fileName || '',
          lineNumber: err.lineNumber || ''
        }
      };
      Logger.addLog(logData);
    };
};

// 在这会导出很多东西供程序使用，当然有些已经挂载到了Vue的原型链上
export {
    Util,
    Global,
    Auth,
    // ...
}
```

## Logger

这是之前版本没有的一个工具，我们来具体看看怎么实现的:

可以看到这里创建了一个Logger类，然后导出了一个logger实例，这样整个框架用的就都是这个logger实例。

然后Logger对象提供了addLog(log)、getAllUser()、readAllLogs(username)、readLogsByTime(timestamp)、readLogsBound(condition)、deleteExpiredLogs()、deleteLogsBeforeTime(timestamp)这些方法供用户使用。

也就是说Logger是按照当前系统的用户来存储其对应的Logger的。

在new Logger的时候，会初始化存放Logger的数据库，也就是说，日志都存在了indexedDB中。

并且Logger会每隔一段时间记录内存占用。

然后接下来很多就是数据库的建立，操作，看不懂，不看了

```js
import Global from './global';

const KFRAME_WEBSQL_DB_NAME = 'kframe_log_db';
const KFRAME_WEBSQL_DB_NEW_VERSION = 1;
const KFRAME_LOG_TABLE = 'kframe_log_table';
const KFRAME_MEMORY_TIMER_INTERVAL = 60000; // 内存监听定时器间隔，单位：毫秒
const KFRAME_LOG_VALID_DAYS = 5; // 日志有效期，5天，超过3天会被删除

class Logger {
  constructor() {
    this.db = undefined; // 数据库链接
    this.store = undefined; // 数据表
    this.logList = []; // 日志列表，添加日志时先添加到这个数组中，再存入数据库
    this.writeTimer = undefined; // 定时器，需要写数据时，开启一个3秒的 timeout
    this.memoryTimer = undefined; // 定时器，每间隔60秒记录一次当前的内存信息

    // 初始化数据库
    this.initDB();
  }

  /* --------------------------- 内部方法 --------------------------- */
  // 初始化数据库
  initDB() {
    // 打开数据库
    let request = indexedDB.open(
      KFRAME_WEBSQL_DB_NAME,
      KFRAME_WEBSQL_DB_NEW_VERSION
    );

    // 监听结果
    request.onerror = (e) => {
      console.error('logger >>> 打开数据库失败');
    };
    request.onsuccess = () => {
      console.warn('logger >>> 打开数据库成功');
      // 获取数据库
      this.db = request.result;

      // 开启内存信息监听的定时器
      this.startMemoryTimer();
    };
    // 如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。
    request.onupgradeneeded = (event) => {
      console.warn('logger >>> 数据库版本更新', event);
      this.db = event.target.result;

      // 创建表
      this.createTable(request, event);
    };
  }

  // 创建表
  createTable(request, event) {
    let objectStore;

    // 创建数据表
    if (!this.db.objectStoreNames.contains(KFRAME_LOG_TABLE)) {
      console.warn('logger >>> 创建表 --- ');
      objectStore = this.db.createObjectStore(KFRAME_LOG_TABLE, {
        autoIncrement: true
        // keyPath: 'id'
      });

      // 创建索引
      objectStore.createIndex('username', 'username', { unique: false });
      objectStore.createIndex('timestamp', 'timestamp', { unique: false });
      objectStore.createIndex('username_timestamp', ['username', 'timestamp'], {
        unique: false
      });
      objectStore.createIndex('username_type', ['username', 'type'], {
        unique: false
      });
      objectStore.createIndex('windowId', 'windowId', { unique: false });
      objectStore.createIndex(
        'username_windowId_time',
        ['username', 'windowId', 'timestamp'],
        { unique: false }
      );
    }

    if (event.oldVersion == 0) {
      // 第一次创建数据库
    } else {
      // 非第一次创建数据库，数据表已经存在，可更新索引
      objectStore = request.transaction.objectStore(KFRAME_LOG_TABLE);

      // 增加或删除索引
    }
  }

  // 清除写日志的定时器
  clearWriteTimer() {
    this.writeTimer && clearTimeout(this.writeTimer);
  }

  /* --------------------------- Public --------------------------- */
  // 开启定时器，记录内存信息
  startMemoryTimer() {
    if (window.performance && window.performance.memory) {
      this.memoryTimer = setInterval(() => {
        // 获取当前内存信息
        let memory = window.performance.memory;

        // 添加日志
        let logData = {
          type: 'memory',
          memory: {
            total: memory.totalJSHeapSize,
            used: memory.usedJSHeapSize,
            limit: memory.jsHeapSizeLimit
          }
        };
        this.addLog(logData);
      }, KFRAME_MEMORY_TIMER_INTERVAL);
    } else {
      console.warn(
        'logger >>> 当前浏览器不支持 window.performance.memory 接口'
      );
    }
  }

  // 清除监听内存的定时器
  stopMemoryTimer() {
    this.memoryTimer && clearInterval(this.memoryTimer);
  }

  /**
   * 添加日志
   * @param {Object} log 日志信息对象
   */
  addLog(log) {
    // 添加 username, timestamp, windowId
    let data = {
      username: Global.getUserInfo().username || '',
      timestamp: Date.now(),
      windowId: Global.getSessionWindowId() || '',
      ...log
    };
    this.logList.push(data);

    // 如果日志数量到达10条（但3秒的定时器还未触发），开启存储
    if (this.logList.length >= 10) {
      this.clearWriteTimer();
      this.insertLogs();
    } else {
      // 日志数量未达到10条，清除旧定时器，并重新开启一个新的定时器，3秒之后存储日志
      this.clearWriteTimer();
      this.writeTimer = setTimeout(() => {
        this.insertLogs();
      }, 3000);
    }
  }

  // 插入数据（将当前 logList 中所有数据都存入数据库）
  insertLogs() {
    if (!this.logList || this.logList.length == 0) {
      return;
    }

    // copy 数组，并清空 logList
    let list = JSON.parse(JSON.stringify(this.logList));
    this.logList = [];

    let insertFailed = [], // 插入失败时保存在这个数组中
      count = 0,
      totalLength = list.length;

    this.store = this.db
      .transaction([KFRAME_LOG_TABLE], 'readwrite')
      .objectStore(KFRAME_LOG_TABLE);
    let startTime = Date.now();
    list.forEach((item) => {
      let request = this.store.add(item);

      request.onsuccess = function(event) {
        count++;
        if (count >= totalLength) {
          // 如果有写入失败的，将其重新添加到 logList 中
          if (insertFailed.length > 0) {
            insertFailed.forEach((failedItem) => {
              this.addLog(failedItem);
            });
          }
        }
      };

      request.onerror = function(event) {
        console.error('logger >>> 数据写入失败 --- ', item);
        count++;
        // 将添加失败的加入到 insertFailed
        insertFailed.push(item);
        if (count >= totalLength) {
          // 如果有写入失败的，将其重新添加到 logList 中
          if (insertFailed.length > 0) {
            insertFailed.forEach((failedItem) => {
              this.addLog(failedItem);
            });
          }
        }
      };
    });
  }

  // 获取所有用户
  getAllUser() {
    return new Promise((resolve, reject) => {
      let list = [];
      let startTime = Date.now();
      this.store = this.db
        .transaction([KFRAME_LOG_TABLE], 'readonly')
        .objectStore(KFRAME_LOG_TABLE);

      // 获取索引
      let dbIndex = this.store.index('username');
      let cursor = dbIndex.openCursor(null, 'nextunique');
      cursor.onsuccess = (event) => {
        let res = event.target.result;
        if (res) {
          list.push(res.value.username);
          res.continue();
        } else {
          resolve(list);
        }
      };

      cursor.onerror = (event) => {
        console.error('读取失败 --- ', event);
        reject(event);
      };
    });
  }

  // 读取当前用户全部日志数据
  readAllLogs(username) {
    return new Promise((resolve, reject) => {
      // let username = Global.getUserInfo().username || ''; // 获取当前用户名
      if (!username) {
        return resolve([]);
      }

      let list = [];
      let startTime = Date.now();
      // let store = db.transaction([KFRAME_LOG_TABLE]).objectStore(KFRAME_LOG_TABLE);
      this.store = this.db
        .transaction([KFRAME_LOG_TABLE], 'readonly')
        .objectStore(KFRAME_LOG_TABLE);
      // 获取索引
      let dbIndex = this.store.index('username');
      let range = IDBKeyRange.only(username);
      let cursor = dbIndex.openCursor(range);
      cursor.onsuccess = function(event) {
        let res = event.target.result;
        if (res) {
          list.push(res.value);
          res.continue();
        } else {
          resolve(list);
        }
      };

      cursor.onerror = (event) => {
        console.error('读取失败 --- ', event);
        reject(event);
      };
    });
  }

  // 读取指定时间的数据
  readLogsByTime(timestamp) {
    return new Promise((resolve, reject) => {
      let list = [];
      let startTime = Date.now();
      // let store = db.transaction([KFRAME_LOG_TABLE]).objectStore(KFRAME_LOG_TABLE);
      this.store = this.db
        .transaction([KFRAME_LOG_TABLE], 'readonly')
        .objectStore(KFRAME_LOG_TABLE);
      let dbIndex = this.store.index('timestamp');
      let range = IDBKeyRange.upperBound(timestamp); // 查询范围 >= timestamp
      let request = dbIndex.openCursor(range);
      request.onsuccess = (event) => {
        let res = event.target.result;
        if (res) {
          list.push(res.value);
          res.continue();
        } else {
          resolve(list);
        }
      };

      request.onerror = (event) => {
        reject(event);
      };
    });
  }

  // 读取指定时间范围内的数据
  readLogsBound(condition) {
    return new Promise((resolve, reject) => {
      let username = condition.username || '';
      if (!username) {
        return resolve([]);
      }

      let list = [];
      let startTime = Date.now();
      // let store = db.transaction([KFRAME_LOG_TABLE]).objectStore(KFRAME_LOG_TABLE);
      this.store = this.db
        .transaction([KFRAME_LOG_TABLE], 'readonly')
        .objectStore(KFRAME_LOG_TABLE);
      let dbIndex = this.store.index('username_timestamp');
      // 前闭后开
      let range = IDBKeyRange.bound(
        [condition.username, condition.startTime],
        [condition.username, condition.endTime],
        false,
        true
      );
      let request = dbIndex.openCursor(range);
      request.onsuccess = (event) => {
        let res = event.target.result;
        if (res) {
          list.push(res.value);
          res.continue();
        } else {
          resolve(list);
        }
      };

      request.onerror = (event) => {
        reject(event);
      };
    });
  }

  // 删除过期的日志数据
  deleteExpiredLogs() {
    // 获取10天前的时间戳，在这个时间之前的日志全部删除
    let today = new Date().setHours(0, 0, 0, 0);
    let timestamp = today - KFRAME_LOG_VALID_DAYS * 86400 * 1000;
    this.deleteLogsBeforeTime(timestamp);
  }

  // 删除指定时间之后的所有日志数据
  deleteLogsBeforeTime(timestamp) {
    return new Promise((resolve, reject) => {
      let startTime = Date.now();
      // 获取表格
      this.store = this.db
        .transaction(KFRAME_LOG_TABLE, 'readwrite')
        .objectStore(KFRAME_LOG_TABLE);

      // 获取索引
      let dbIndex = this.store.index('timestamp');
      // 构建查询
      let range = IDBKeyRange.upperBound(timestamp);
      // 查询数据并删除
      let request = dbIndex.openCursor(range);
      let count = 0;
      request.onsuccess = (event) => {
        let res = event.target.result;
        if (res) {
          res.delete(); // 删除当前记录
          count++;
          res.continue();
        } else {
          resolve(count);
        }
      };
    });
  }
}

export default new Logger();
```



