---
title: kFrame总结
date: 2022-01-14 15:55:03 
permalink: /k-frame-learning/ 
id: k-frame-learning
categories:
  - 前端
tags:
  - 前端
  - Vue
  - 框架
---



# kFrame 总结

在k公司做了挺久，我想总结一下k公司的前端框架

## KeepAlive

```vue
    <transition name="fade-transform" mode="out-in">
        <keep-alive :include="keepAliveIncludeList" v-if="customize.keepAliveMode">
            <router-view :key="key"></router-view>
        </keep-alive>
        <keep-alive :exclude="keepAliveExcludeList" :max="customize.keepAliveMax" v-else>
            <router-view :key="key"></router-view>
        </keep-alive>
    </transition>
```

将`keepAliveIncludeList`、`keepAliveExcludeList`放在vuex中，并且根据配置来切换keepAlive的模式，每次切换模式都会清空缓存（因为 v-if 和 v-else 的变换）。

## 如何保证配置都被读取后进行页面加载

```js
Global.init().then(async () => {
  new Vue({
    el: '#app',
    router: router,
    store: store,
    render: h => h(App)
  });
}).catch((err) => {
  console.error('global init err' + err);
});
```

通过全局的init方法读取配置，然后再 new Vue 实例。

## 全局工具的提供

```js
import Global from 'utils/global';
```

框架中会这样使用 Global、Utils等工具类函数。

同时框架提供了默认的utils。

为了使用框架的utils需要在项目中，创建utils/global.js：

```js
/** global.js **/
import global from 'kframe/utils/global';

// 自定义 或者 覆盖 global 上的方法
// global.xxx = () => {}

export default global;
```

## 换肤

每种样式需要写一套，分别放在light、dark目录下面。

编译的时候，使用gulp将样式分别编译到 static/light 、 static/dark 目录下面。

初始化的时候，加入`<style>`标签；

换肤：改变`<style>`路径中的dark、light关键词

gulp 编译使用的插件 `gulp-px2rem-plugin` `gulp-sass` `gulp-autoprefixer`   `gulp-cssmin` `node-sass-tilde-importer`



## webpack 配置

package.json

```json
{
    	"scripts": {
		"import": "node submodule import -ALL",
		"dev": "node --max_old_space_size=4096 node_modules/webpack-dev-server/bin/webpack-dev-server.js --inline --progress --config build/webpack.dev.conf.js",
		"start": "npm run dev",
		"lint-fix": "eslint --fix --ext .js,.vue src",
		"unit": "jest --config test/unit/jest.conf.js --coverage",
		"e2e": "node test/e2e/runner.js",
		"test": "npm run unit && npm run e2e",
		"lint": "eslint --ext .js,.vue src test/unit/specs test/e2e/specs",
		"clean": "rimraf dist && rimraf  static/theme/dark/lib && rimraf  static/theme/light/lib",
		"build:theme:dark": "gulp build --gulpfile static/theme/dark/gulpfile.js",
		"build:theme:light": "gulp build --gulpfile static/theme/light/gulpfile.js",
		"build:theme": "npm run clean && npm run build:theme:dark && npm run build:theme:light",
		"build": "npm run build:theme && node --max_old_space_size=4096 build/build.js",
		"server": "node test/webserver/index.js"
	}
}
```

可以看到，在build的时候，会先使用gulp编译主题，这样做也是考虑到了换肤方案。然后就是执行build.js。

由于项目比较大，所以内存给了4G。

dev使用了webpack-dev-server 然后提供dev的webpack配置。

dev配置是基于base配置，所以先看base配置

```js
'use strict';
const path = require('path');
const utils = require('./utils');
const config = require('../config');
const vueLoaderConfig = require('./vue-loader.conf');
const {readdirSync, existsSync,mkdirSync,lstatSync} = require('fs');
let excludeEslint = [];

// 将submodule的静态资源放入excludeEslint
readdirSync('./submodule').forEach(item => {
	excludeEslint.push(resolve(`submodule/${item}/assets`));
});
// 提供resolve，因为这个文件在/build/目录下面
function resolve (dir) {
	return path.join(__dirname, '..', dir);
}
// 将内部组件的静态资源都放入项目的静态资源
if(existsSync(`./node_modules/@k-components`)){
	let dirs = readdirSync('./node_modules/@k-components');
	dirs.forEach(name =>{
		if(existsSync(`./node_modules/@k-components/${name}/static/${name}`) && lstatSync(`./node_modules/@k-components/${name}/static/${name}`).isDirectory()){
			if(!existsSync(`./static/${name}`)){
				mkdirSync(`./static/${name}`);
			}
			utils.existsDst(`./node_modules/@k-components/${name}/static/${name}`,`./static/${name}`, utils.copy);
		}
	});
}
module.exports = {
	node:{fs:'empty'},
	context: path.resolve(__dirname, '../'),
	entry: {
		main: ['babel-polyfill', './main/main.js']
	},
	output: {
		path: config.build.assetsRoot,
		filename: '[name].js',
		publicPath: process.env.NODE_ENV === 'production'
			? config.build.assetsPublicPath
			: config.dev.assetsPublicPath
	},
	resolve: {
		extensions: ['.js', '.vue', '.json'],
		alias: {
			'vue$': 'vue/dist/vue.esm.js',
			'main': resolve('main'),
			'submodule': resolve('submodule'),
			'utils': resolve('utils'),
			'config': resolve('config'),
			'static': path.resolve(__dirname, '../static') // 不参与打包文件路径
		}
	},
	module: {
		unknownContextCritical : false,
		rules: [
            // eslint
			...(config.dev.useEslint ? [{
				test: /\.(js|vue)$/,
				loader: 'eslint-loader',
				enforce: 'pre',
				include: [resolve('submodule'), resolve('main'), resolve('test')],
				exclude: excludeEslint,
				options: {
					formatter: require('eslint-friendly-formatter'),
					emitWarning: !config.dev.showEslintErrorsInOverlay
				}
			}] : []),
            // vue
			{
				test: /\.vue$/,
				loader: 'vue-loader',
				options: vueLoaderConfig
			},
            // babel 需要一同将内部的组件包括
			{
				test: /\.js$/,
				loader: 'babel-loader',
				include: [resolve('submodule'), resolve('main'), resolve('node_modules/@k-components/k-baseui'), resolve('config'), resolve('build'), resolve('static'), resolve('utils'), resolve('test')]
			},
            // 样式
			{
				test: /\.sass$/,
				loaders: ['style', 'css', 'scss']
			},
            // 其他资源
			{
				test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
				loader: 'url-loader',
				options: {
					limit: 10000,
					name: utils.assetsPath('img/[name].[hash:7].[ext]')
				}
			},
			{
				test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
				loader: 'url-loader',
				options: {
					limit: 10000,
					name: utils.assetsPath('media/[name].[hash:7].[ext]')
				}
			},
			{
				test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
				loader: 'url-loader',
				options: {
					limit: 10000,
					name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
				}
			}
		]
	}
};
```

接下来是dev.config

```js
'use strict'
const utils = require('./utils')
const webpack = require('webpack')
const config = require('../config')
const merge = require('webpack-merge')
const baseWebpackConfig = require('./webpack.base.conf')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')
const portfinder = require('portfinder');
const {readdirSync, lstatSync, existsSync} = require('fs');
const htmlWebpackPluginConfig = {
	filename: 'index.html',
	template: `index.html`,
	inject: true,
	chunks: ['main']
}

// 内部插件
readdirSync('./submodule').forEach(name => {
	if(lstatSync(`./submodule/${name}`).isDirectory() && existsSync(`./submodule/${name}/package.json`)){
		let packageJson = require(`../submodule/${name}/package.json`);
		console.log('packageJson>>>', packageJson);
		if(packageJson.scripts['sockjs']){
			htmlWebpackPluginConfig.sockjs = true;
		}
	}
});

// 首先合并基础配置
const devWebpackConfig = merge(baseWebpackConfig, {
	module: {
		rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
	},
	// cheap-module-eval-source-map is faster for development
	devtool: config.dev.devtool,

	// these devServer options should be customized in /config/index.js
	devServer: {
		clientLogLevel: 'warning',
		historyApiFallback: true,
		hot: true,
		compress: true,
		host: process.env.HOST || config.dev.host,
		port: process.env.PORT || config.dev.port,
		open: config.dev.autoOpenBrowser,
		overlay: config.dev.errorOverlay ? {
			warnings: false,
			errors: true,
		} : false,
		publicPath: config.dev.assetsPublicPath,
		proxy: config.dev.proxyTable,
		quiet: true, // necessary for FriendlyErrorsPlugin
		watchOptions: {
			poll: config.dev.poll,
		}
	},
	plugins: [
		new webpack.DefinePlugin({
			'process.env': require('../config/dev.env')
		}),
		new webpack.HotModuleReplacementPlugin(),
		new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.
		new webpack.NoEmitOnErrorsPlugin(),
		// https://github.com/ampedandwired/html-webpack-plugin
		new HtmlWebpackPlugin(htmlWebpackPluginConfig)
	]
})

module.exports = new Promise((resolve, reject) => {
	portfinder.basePort = process.env.PORT || config.dev.port
	portfinder.getPort((err, port) => {
		if (err) {
			reject(err)
		} else {
		// publish the new Port, necessary for e2e tests
		process.env.PORT = port
		// add port to devServer config
		devWebpackConfig.devServer.port = port

		// Add FriendlyErrorsPlugin
		devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({
			compilationSuccessInfo: {
				messages: [`Your application is running here: http://${config.dev.host}:${port}`],
			},
			onErrors: config.dev.notifyOnErrors
				? utils.createNotifierCallback()
				: undefined
		}))

		resolve(devWebpackConfig)
		}
	})
})

```

